#include <iostream>

// задача о связности

constexpr unsigned int N = 20;

inline void print(const int p, const int q, const int* A) {
	std::cout << " " << p << " " << q << "\t";
	for (int i = 0; i < N; ++i)
		std::cout << A[i] << " ";
	std::cout << std::endl;
}

inline void quick_search() {

	// смысл в том, что в id[index] будет записано число, с которым оно связано
	// так, если таких чисел несколько (связанных с одним и тем же числом), то переопределятся все на q

	int i, p, q, id[N];

	for (i = 0; i < N; ++i)
		id[i] = i; // заполнение таблицы чисел

	print(0, 0, id);

	while (std::cin >> p >> q) {
		int temp = id[p];

		if (temp == id[q]) // значит связаны уже
			continue;

		for (i = 0; i < N; ++i)
			if (id[i] == temp) // если нашли связанную с id[p]
				id[i] = id[q]; // указываем на этом индексе связанные с ним числа

		print(p, q, id);
	}

	//	 0 0    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	//	 0 2
	//	  0 2    2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	//	 2 5
	//	  2 5    5 1 5 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	//	 4 9
	//	  4 9    5 1 5 3 9 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	//	 2 4
	//	  2 4    9 1 9 3 9 9 6 7 8 9 10 11 12 13 14 15 16 17 18 19

};

// т.к. перезаписываются все элементы, то операция "union" требовательная
// можно заменить - ракручивать поуказательно, т.е. тратить на операцию "for" больше, a на union - меньше

inline void quick_union() {

	// смысл в том, что каждый id[index] содержит в себе указатель на другой объект,
	// и если вдруг последний (после разворачивания всех указателей) указывает сам на себя,
	// значит он заканчивает цепочку.
	// два объекта в одной коллекции указывают на одинаковое число-замыкатель

	int i, j, p, q, id[N];

	for (i = 0; i < N; ++i)
		id[i] = i; // заполнение таблицы чисел

	print(0, 0, id);

	while (std::cin >> p >> q) {
		
		for (i = p; i != id[i]; i = id[i]); // раскручиваем "указатели"
		for (j = q; j != id[j]; j = id[j]);	// и тут тоже

		if (i == j) // значит связаны уже
			continue;

		id[i] = j; // в раскрученный указатель по i записываем число-замыкатель по j

		print(p, q, id);
	}
	// 0 0    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	// 2 3
	//  2 3    0 1 3 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	// 5 2
	//  5 2    0 1 3 3 4 3 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	// 6 2
	//  6 2    0 1 3 3 4 3 3 7 8 9 10 11 12 13 14 15 16 17 18 19
	// 3 10
	//  3 10   0 1 3 10 4 3 3 7 8 9 10 11 12 13 14 15 16 17 18 19
	// 2 11
	//  2 11   0 1 3 10 4 3 3 7 8 9 11 11 12 13 14 15 16 17 18 19
	// 16 2
	//  16 2   0 1 3 10 4 3 3 7 8 9 11 11 12 13 14 15 11 17 18 19
};

// этот вариант может быть плох, т.к. в худшем случае будет цепочная 1-2-3-4-5...-20
// т.е. будто и нет никаких деревьев
// следовательно, стоит как-то определить и взвешивать связи

inline void quick_weighted_union() {

	int i, j, p, q, id[N];
	int sz[N]; // он будет хранить информацию о том, где связанных узлов больше

	for (i = 0; i < N; ++i) {
		id[i] = i; // заполнение таблицы чисел
		sz[i] = 1;
	}

	print(0, 0, id);

	while (std::cin >> p >> q) {
		
		for (i = p; i != id[i]; i = id[i]); // раскручиваем "указатели"
		for (j = q; j != id[j]; j = id[j]);	// и тут тоже

		// для ускорения - можно сжимать путь пополам:
		// for (i = p; i != id[i]; i = id[i]) {id[i] = id[id[i]]};
		// ошибок не будет, т.к. он укажет сам на себя

		if (i == j) // значит связаны уже
			continue;

		if (sz[i] < sz[j]) {
			id[i] = j; sz[j] += sz[i];
		} else {
			id[j] = i; sz[i] += sz[j];
		}

		print(p, q, id);
	}
};


int main() {
	quick_weighted_union();
	return 0;
}